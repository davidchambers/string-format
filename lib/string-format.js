// Generated by CoffeeScript 1.4.0

/*
Source code and build tools for this file are available at:
https://github.com/deleted/string-format

This project attempts to implement python-style string formatting, as documented here:
http://docs.python.org/2/library/string.html#format-string-syntax

The format spec part is not complete, but it can handle field padding, float precision, and such
*/


(function() {
  var applyFormat, format, lookup, resolve,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  format = String.prototype.format = function() {
    var args, explicit, idx, implicit, message,
      _this = this;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.format.apply(_this, args);
      };
    }
    idx = 0;
    explicit = implicit = false;
    message = 'cannot switch from {} to {} numbering'.format();
    return this.replace(/([{}])\1|[{](.*?)(?:!([^:]+?)?)?(?::(.+?))?[}]/g, function(match, literal, key, transformer, formatSpec) {
      var fn, value, _ref, _ref1, _ref2;
      if (literal) {
        return literal;
      }
      if (key.length) {
        explicit = true;
        if (implicit) {
          throw new Error(message('implicit', 'explicit'));
        }
        value = (_ref = lookup(args, key)) != null ? _ref : '';
      } else {
        implicit = true;
        if (explicit) {
          throw new Error(message('explicit', 'implicit'));
        }
        value = (_ref1 = args[idx++]) != null ? _ref1 : '';
      }
      if (formatSpec) {
        value = applyFormat(value, formatSpec);
      } else {
        value = value.toString();
      }
      if (fn = format.transformers[transformer]) {
        return (_ref2 = fn.call(value)) != null ? _ref2 : '';
      } else {
        return value;
      }
    });
  };

  lookup = function(object, key) {
    var match;
    if (!/^(\d+)([.]|$)/.test(key)) {
      key = '0.' + key;
    }
    while (match = /(.+?)[.](.+)/.exec(key)) {
      object = resolve(object, match[1]);
      key = match[2];
    }
    return resolve(object, key);
  };

  resolve = function(object, key) {
    var value;
    value = object[key];
    if (typeof value === 'function') {
      return value.call(object);
    } else {
      return value;
    }
  };

  applyFormat = function(value, formatSpec) {
    var align, comma, fill, hash, isNumeric, memoSign, pattern, precision, sign, type, width, zeropad, _ref, _ref1, _ref2;
    pattern = /([^{}](?=[<>=^]))?([<>]^)?([\+\-\x20])?(\#)?(0)?(\d+)?(,)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?/;
    _ref = formatSpec.match(pattern).slice(1), fill = _ref[0], align = _ref[1], sign = _ref[2], hash = _ref[3], zeropad = _ref[4], width = _ref[5], comma = _ref[6], precision = _ref[7], type = _ref[8];
    if (zeropad) {
      fill = "0";
      align = "=";
    }
    if (!align) {
      align = '>';
    }
    switch (type) {
      case 'b':
      case 'c':
      case 'd':
      case 'o':
      case 'x':
      case 'X':
      case 'n':
        isNumeric = true;
        value = '' + parseInt(value);
        break;
      case 'e':
      case 'E':
      case 'f':
      case 'F':
      case 'g':
      case 'G':
      case 'n':
      case '%':
        isNumeric = true;
        value = parseFloat(value);
        if (precision) {
          value = value.toFixed(parseInt(precision));
        } else {
          value = '' + value;
        }
        break;
      case 's':
        isNumeric = false;
        value = '' + value;
    }
    if (isNumeric && sign) {
      if (sign === "+" || sign === " ") {
        if (value[0] !== '-') {
          value = sign + value;
        }
      }
    }
    if (isNumeric && (_ref1 = value[0], __indexOf.call("+-", _ref1) >= 0)) {
      memoSign = value[0];
      value = value.slice(1);
    }
    if (fill) {
      value = '' + value;
      while (value.split('.')[0].length < parseInt(width)) {
        switch (align) {
          case '=':
            if (_ref2 = value[0], __indexOf.call("+- ", _ref2) >= 0) {
              value = value[0] + fill + value.slice(1);
            } else {
              value = fill + value;
            }
            break;
          case '<':
            value = value + fill;
            break;
          case '>':
            value = fill + value;
            break;
          case '^':
            throw new Error("Not implemented");
        }
      }
    }
    if (memoSign) {
      value = memoSign + value;
    }
    return value;
  };

  format.transformers = format.transformers || {};

  format.version = '0.2.1';

}).call(this);
